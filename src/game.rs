use std::collections::HashMap;
use std::sync::Mutex;
use uuid::Uuid;
use serde::{Serialize, Deserialize};
use crate::game::GameStatus::{OWon, XWon};

pub enum GameStatus {
    RUNNING,
    XWon,
    OWon,
    DRAW,
}

pub struct GameList{
    pub list: Mutex<HashMap<String,Game>>
}

#[derive(Clone)]
#[derive(Serialize)]
#[derive(Deserialize)]
pub struct Game {
    /// The game's UUID, read-only, generated by the server. The client can not POST or PUT this.
    id: Option<String>,

    /// The board state
    board: String,

    /// The game status, read-only, the client can not POST or PUT this
    status: Option<String>
}

impl Game {
    /// Creates a new game instance
    pub fn new(board: String) -> Game {
        Game {
            id: Some(Uuid::new_v4().to_string()),
        status: Some(String::from("RUNNING")),
        board
        }
    }

    pub fn set_board(&mut self, board: String) {
        self.board = board
    }

    pub fn get_board(&self) -> &String {
        &self.board
    }
    pub fn get_status(&self) -> &Option<String>  {
        &self.status
    }
    pub fn set_status(&mut self, game_status: GameStatus) {
        match game_status {
            GameStatus::RUNNING => self.status = Some(String::from("RUNNING")),
            GameStatus::XWon => self.status = Some(String::from("X_WON")),
            GameStatus::OWon => self.status = Some(String::from("O_WON")),
            GameStatus::DRAW => self.status = Some(String::from("DRAW"))
        }
    }

    pub fn get_id(&self) -> &Option<String> {
        &self.id
    }

    pub fn board_is_empty(&self) -> bool {
        let mut empty = true;
        let current_board = &self.board.clone();
        for c in current_board.chars() {
            if c == 'O' || c == 'X' {
                empty = false;
                break
            }
        }
        empty
    }

    pub fn check_win_conditions(&mut self) -> bool {
        let board_rows: Vec<&str>;
        let current_board = &self.board.clone();
        let row0 = &current_board[0..3];
        let row1 = &current_board[3..6];
        let row2 = &current_board[6..];
        board_rows = vec!(row0, row1, row2);

        // temporary variables for logic use
        let mut win_x: bool = false;
        let mut win_o: bool = false;
        let draw: bool = false;

        // This is a bit slow but there's no clever way to take the character as an input
        // since the game object stores it as a single string anyway and the function would
        // just have to be duplicated on each type of move function.
        // That and since the board is 9 characters long, the impact is negligible even on low power devices

        // Checking rows for X
        for rows in &board_rows {
            win_x = true;
            for char in rows.chars() {
                // If all chars are X, win is true and loop won't break
                if char != 'X' {
                    win_x = false;
                    break
                }
            }
            // terminates with a win, X has won, break loop
            if win_x {
                let _ = &self.set_status(XWon);
                return true;
            }
        }

        // Checking rows for O
        for rows in &board_rows {
            win_o = true;
            for char in rows.chars() {
                // If all chars are O, win is true and loop won't break
                if char != 'O' {
                    win_o = false;
                    break
                }
            }
            // terminates with a win, O has won, break loop
            if win_o {
                let _ = &self.set_status(OWon);
                return true;
            }
        }

        //Checking columns
        // Preparing rows for parallel iteration
        let r0 = row0.chars();
        let r12 = row1.chars().zip(row2.chars());

        // Iterating over all the rows parallel
        for (r0, r12) in r0.zip(r12) {
            let r0_char = r0;
            let (r1_char, r2_char) = r12;

            // If all characters are the same, check which one they are and behave accordingly
            if (r0_char == r1_char) && (r2_char == r0_char)  {
                match r0_char {
                    'X' => self.set_status(XWon),
                    'O' => self.set_status(OWon),
                    _ => continue
                }
            }
        }


        false
    }
}


