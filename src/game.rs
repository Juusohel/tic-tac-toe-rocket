use std::collections::HashMap;
use std::sync::Mutex;
use uuid::Uuid;
use serde::{Serialize, Deserialize};

pub enum GameStatus {
    RUNNING,
    XWon,
    OWon,
    DRAW,
}

pub struct GameList{
    pub list: Mutex<HashMap<String,Game>>
}

#[derive(Clone)]
#[derive(Serialize)]
#[derive(Deserialize)]
pub struct Game {
    /// The game's UUID, read-only, generated by the server. The client can not POST or PUT this.
    id: Option<String>,

    /// The board state
    board: String,

    /// The game status, read-only, the client can not POST or PUT this
    status: Option<String>
}


impl Game {
    /// Creates a new game instance
    pub fn new(board: String) -> Game {
        Game {
            id: Some(Uuid::new_v4().to_string()),
        status: Some(String::from("RUNNING")),
        board
        }
    }

    pub fn set_board(&mut self, board: String) {
        self.board = board
    }

    pub fn get_board(&self) -> &String {
        &self.board
    }
    pub fn get_status(&self) -> &Option<String>  {
        &self.status
    }
    pub fn set_status(&mut self, game_status: GameStatus) {
        match game_status {
            GameStatus::RUNNING => self.status = Some(String::from("RUNNING")),
            GameStatus::XWon => self.status = Some(String::from("X_WON")),
            GameStatus::OWon => self.status = Some(String::from("O_WON")),
            GameStatus::DRAW => self.status = Some(String::from("DRAW"))
        }
    }

    pub fn get_id(&self) -> &Option<String> {
        &self.id
    }


}
